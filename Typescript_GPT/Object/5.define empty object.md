```typescript
type literal = "one" | "two" | "three";
const filesds: { [key in literal]: string } = {};
```

## if I want to define empty object, add keys later

In TypeScript, if you declare a type such that an object must have specific keys, as you've done with the mapped type where `key` must be one of the literals `"one"`, `"two"`, or `"three"`, TypeScript expects these keys to be present on the object. Here’s how to work with this requirement:

### Defining an Initially Empty Object

TypeScript's type system is designed to enforce strict adherence to type definitions at compile time, meaning that if a type defines certain keys, those keys must be present on any object of that type. However, if you want to initialize an object without those keys and add them later, you have a couple of options:

#### Option 1: Use Partial

You can use TypeScript’s utility type `Partial<T>` to make all properties of a type optional. This allows you to start with an empty object and add properties later:

```typescript
type Literal = "one" | "two" | "three";

const fields: Partial<{ [key in Literal]: string }> = {};
// Now fields is { one?: string; two?: string; three?: string; }

// Adding keys later
fields.one = "Value for one";
fields.two = "Value for two";
fields.three = "Value for three";
```

#### Option 2: Type Assertions

You can use a type assertion to tell TypeScript to treat an object as having a certain type, even if it doesn’t initially fulfill the type's requirements. This should be used cautiously because it bypasses TypeScript’s static type checking:

```typescript
type Literal = "one" | "two" | "three";

let fields = {} as { [key in Literal]: string };
// Be careful: fields now incorrectly assumes all keys are present!

// You can now add keys one by one
fields.one = "Value for one";
fields.two = "Value for two";
fields.three = "Value for three";
```

### Important Considerations

When using these methods, especially type assertions, you need to be aware that you're circumventing TypeScript's safety mechanisms. This can lead to runtime errors if you access properties that have not yet been assigned. For instance, if you try to access `fields.one` before it's set, you will get `undefined`, which might not be expected in your program logic.

### Better Approach

If the structure of your object allows for dynamic keys but you still want to enforce certain values only for specific keys, you might want to reconsider the design. Perhaps defining a base type and then extending it when the full structure is known or dynamically adding properties as needed within controlled parts of your codebase.

Using `Partial` generally is the safest approach as it maintains type safety and avoids the pitfalls of type assertions, giving you the flexibility to start with an empty object and add properties as required.
