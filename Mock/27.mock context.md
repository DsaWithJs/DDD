To mock a context provider in React while using TypeScript, you'll need to incorporate type safety into your testing setup. Here's how you can approach this with TypeScript support, ensuring that your types align with your context and component expectations. I'll also demonstrate how to properly type the mock implementation of a context and the context provider itself.

### Step 1: Define Your Context with TypeScript

Let's use the example of a `ThemeContext` that provides a theme and a method to toggle it. We'll define it using TypeScript to ensure type safety throughout the application and tests.

**ThemeContext.tsx**

```typescript
import React, { createContext, useContext, useState, ReactNode } from "react";

type Theme = "light" | "dark";

interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const useTheme = (): ThemeContextType => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
};

interface ThemeProviderProps {
  children: ReactNode;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const [theme, setTheme] = useState<Theme>("light");

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
  };

  return <ThemeContext.Provider value={{ theme, toggleTheme }}>{children}</ThemeContext.Provider>;
};
```

### Step 2: Mock the Context in Tests with TypeScript

When writing tests, you can mock the `useTheme` hook to return controlled values. Here's how to set it up in TypeScript.

**ComponentUsingTheme.tsx**

```typescript
import React from "react";
import { useTheme } from "./ThemeContext";

const ComponentUsingTheme: React.FC = () => {
  const { theme, toggleTheme } = useTheme();

  return (
    <div>
      Current theme: {theme}
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
};

export default ComponentUsingTheme;
```

**ComponentUsingTheme.test.tsx**

```typescript
import React from "react";
import { render, fireEvent, screen } from "@testing-library/react";
import ComponentUsingTheme from "./ComponentUsingTheme";
import { useTheme } from "./ThemeContext";

jest.mock("./ThemeContext", () => ({
  useTheme: jest.fn(),
}));

describe("ComponentUsingTheme", () => {
  it("renders with light theme", () => {
    (useTheme as jest.Mock).mockReturnValue({
      theme: "light",
      toggleTheme: jest.fn(),
    });

    render(<ComponentUsingTheme />);
    expect(screen.getByText("Current theme: light")).toBeInTheDocument();
  });

  it("allows theme to be toggled", () => {
    const toggleTheme = jest.fn();
    (useTheme as jest.Mock).mockReturnValue({
      theme: "dark",
      toggleTheme,
    });

    render(<ComponentUsingTheme />);
    fireEvent.click(screen.getByText("Toggle Theme"));
    expect(toggleTheme).toHaveBeenCalled();
  });
});
```

### Key TypeScript Considerations:

- **Type Assertions**: Use `as jest.Mock` to cast the mocked functions so TypeScript knows these are jest mocks and not the actual functions.
- **Interface and Type Definitions**: Define clear interfaces and types for your context to ensure type correctness throughout your application and tests.
- **Error Handling**: Ensure that your context consumers are safely accessing the context by checking for undefined, which is a common scenario that TypeScript can help avoid.

### Alternative: Custom Render Function with TypeScript

If you prefer to mock the provider directly rather than individual hooks, you can create a custom render function in TypeScript that includes your mocked context:

```typescript
import { render, RenderOptions } from "@testing-library/react";

interface CustomRenderOptions extends RenderOptions {
  providerProps: ThemeContextType;
}

const customRender = (ui: React.ReactElement, { providerProps, ...renderOptions }: CustomRenderOptions) => {
  return render(<ThemeContext.Provider value={providerProps}>{ui}</ThemeContext.Provider>, renderOptions);
};

// Usage in a test
test("uses custom theme provider", () => {
  const providerProps: ThemeContextType = { theme: "dark", toggleTheme: jest.fn() };
  customRender(<ComponentUsingTheme />, { providerProps });
  expect(screen.getByText("Current theme: dark")).toBeInTheDocument();
});
```

This approach maintains type safety while allowing full control over the context values in each test, effectively leveraging TypeScript's capabilities to ensure robust, maintainable tests.
